import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
from model import DeputyRecommender
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import numpy as np

# Set the page configuration to wide
st.set_page_config(layout="wide")

# Load the deputies data to populate the dropdown menu
data_path = 'enriched_df.csv'
df = pd.read_csv(data_path, encoding='utf-8')

# Initialize the recommender
recommender = DeputyRecommender(data_path)

# Streamlit app
st.title('Deputy Recommender System')

# Sidebar for navigation
page = st.sidebar.selectbox("Choose a page", ["Recommender", "Chat with Dataset"])

if page == "Recommender":
    # Dropdown menu for selecting a deputy
    deputy_name = st.selectbox('Select a Deputy:', df['name'].unique())

    # Number of recommendations to display
    top_n = st.slider('Number of Recommendations:', 1, 5, 3)

    # Button to get recommendations
    if st.button('Get Recommendations'):
        # Get the deputy_id based on the selected deputy_name
        deputy_id = df.loc[df['name'] == deputy_name, 'deputy_id'].values[0]
        
        try:
            recommendations = recommender.recommend_by_id(deputy_id, top_n)
            st.write(f"Recommendations for {deputy_name}:")
            
            # Display the main deputy's photo and data
            cols = st.columns([1, 3])
            with cols[0]:
                main_deputy_photo_url = df.loc[df['deputy_id'] == deputy_id, 'photo_url'].values[0]
                st.image(main_deputy_photo_url, caption=deputy_name, width=150)
            
            with cols[1]:
                # Create a dashboard view for the main deputy
                st.subheader("Main Deputy Information")
                st.write(f"**Name:** {deputy_name}")
                st.write(f"**ID:** {deputy_id}")
                st.write("*Ideology, populist elements (score 0 to 1) and agenda was generated by using Zero Shot GPT API for summarize the propositions of the deputy.")
                
                # Plot categorical features
                categorical_features = ['party_classification', 'ideology', 'party', 'state']
                for feature in categorical_features:
                    deputy_value = df.loc[df['deputy_id'] == deputy_id, feature].values[0]
                    st.write(f"**{feature.replace('_', ' ').title()}:** {deputy_value}")
            
            st.subheader("Deputy Metrics in Comparison")

            # Plot numerical features compared to the dataset mean and median
            numerical_features = ['attendance_rate', 'cost_per_proposition', 'populist_elements', 'proposition_count', 'total_expenses']
            cols = st.columns(2)
            
            for i, feature in enumerate(numerical_features):
                deputy_value = df.loc[df['deputy_id'] == deputy_id, feature].values[0]
                # Handle NaN values in mean/median calculations
                clean_series = df[feature].dropna()
                mean_value = clean_series.mean() if not clean_series.empty else 0
                median_value = clean_series.median() if not clean_series.empty else 0
                
                # Handle division by zero in percentage calculation
                if mean_value != 0:
                    percentage_diff = ((deputy_value - mean_value) / mean_value) * 100
                else:
                    percentage_diff = 0
                
                cols[i % 2].write(f"**{feature.replace('_', ' ').title()}:** "
                                  f"{deputy_value:.2f} | Mean: {mean_value:.2f} | "
                                  f"Median: {median_value:.2f} | "
                                  f"Diff: {percentage_diff:+.1f}%")
                
                # Collect values for the recommendations
                rec_values = [df.loc[df['deputy_id'] == rec['deputy_id'], feature].values[0] for rec in recommendations['similar_deputies']]
                fig = px.bar(
                    x=['Deputy', 'Mean', 'Median'] + [rec['name'] for rec in recommendations['similar_deputies']], 
                    y=[deputy_value, mean_value, median_value] + rec_values, 
                    labels={'x': '', 'y': feature.replace('_', ' ').title()},
                    color_discrete_sequence=['blue', 'lightblue', 'lightblue'] + ['gray'] * len(recommendations['similar_deputies'])
                )
                fig.update_traces(marker=dict(color=['blue', 'lightblue', 'lightblue'] + ['gray'] * len(recommendations['similar_deputies'])))
                cols[i % 2].plotly_chart(fig, use_container_width=True)

            # Improved Radar Chart with filled areas
            radar_features = numerical_features
            main_deputy_data = df.loc[df['deputy_id'] == deputy_id, radar_features].values.flatten().tolist()

            # Collect all values for axis range calculation
            all_values = main_deputy_data.copy()
            for rec in recommendations['similar_deputies']:
                rec_data = df.loc[df['deputy_id'] == rec['deputy_id'], radar_features].values.flatten().tolist()
                all_values.extend(rec_data)
            max_value = max(all_values) * 1.2  # Add 20% padding

            fig = go.Figure()

            # Add main deputy trace with filled area
            fig.add_trace(go.Scatterpolar(
                r=main_deputy_data,
                theta=radar_features,
                fill='toself',
                name=deputy_name,
                line=dict(color='blue', width=2),
                fillcolor='rgba(0, 116, 217, 0.4)',
                hoverinfo='name+r+theta'
            ))

            # Add recommendations' traces with different colors
            colors = px.colors.qualitative.Dark24
            for i, rec in enumerate(recommendations['similar_deputies']):
                rec_data = df.loc[df['deputy_id'] == rec['deputy_id'], radar_features].values.flatten().tolist()
                fig.add_trace(go.Scatterpolar(
                    r=rec_data,
                    theta=radar_features,
                    fill='toself',
                    name=rec['name'],
                    line=dict(color=colors[i], width=1.5),
                    fillcolor=colors[i].replace('rgb', 'rgba').replace(')', ',0.2)'),
                    hoverinfo='name+r+theta'
                ))

            # Update layout for better radar visualization
            fig.update_layout(
                polar=dict(
                    radialaxis=dict(
                        visible=True,
                        range=[0, max_value],
                        gridcolor='rgba(200, 200, 200, 0.5)',
                        gridwidth=1,
                        showline=False,
                    ),
                    angularaxis=dict(
                        gridcolor='rgba(200, 200, 200, 0.5)',
                        linecolor='gray',
                    ),
                    bgcolor='rgba(245, 245, 245, 0.5)'
                ),
                legend=dict(
                    orientation="h",
                    yanchor="bottom",
                    y=1.02,
                    xanchor="right",
                    x=1
                ),
                margin=dict(l=100, r=100, t=40, b=40),
                height=500,
                title_text="Metrics Radar Comparison",
                title_x=0.5,
                showlegend=True
            )

            st.plotly_chart(fig, use_container_width=True)

            # Scatter plot for cost vs proposition
            st.subheader("Cost vs Proposition Count")
            fig = make_subplots(rows=1, cols=2, subplot_titles=("Cost vs Proposition Count", "Share of Expenses"))
            
            scatter = px.scatter(df, x='total_expenses', y='proposition_count', opacity=0.5, color_discrete_sequence=['gray'])
            scatter.add_scatter(x=[df.loc[df['deputy_id'] == deputy_id, 'total_expenses'].values[0]], 
                                y=[df.loc[df['deputy_id'] == deputy_id, 'proposition_count'].values[0]], 
                                mode='markers', marker=dict(color='blue', size=10), name=deputy_name)
            fig.add_trace(scatter.data[0], row=1, col=1)
            fig.add_trace(scatter.data[1], row=1, col=1)
            
            # Bar plot for share of expenses
            expense_features = ['taxi_toll_parking', 'flight_passages', 'office_maintenance', 'fuel_lubricants', 'total_expenses']
            expense_values = df.loc[df['deputy_id'] == deputy_id, expense_features].values.flatten().tolist()
            bar = go.Bar(x=expense_features, y=expense_values, marker=dict(color='blue'))
            fig.add_trace(bar, row=1, col=2)
            
            fig.update_layout(showlegend=False)
            st.plotly_chart(fig, use_container_width=True)
            
            # Option to show/hide the table
            if st.checkbox('Show Deputy Data Table'):
                st.write(df[df['deputy_id'] == deputy_id].T)
            
            # Plot a row of recommendations with improved text display
            st.subheader("Recommendations")
            cols = st.columns(top_n)
            for i, rec in enumerate(recommendations['similar_deputies']):
                with cols[i]:
                    rec_photo_url = df.loc[df['deputy_id'] == rec['deputy_id'], 'photo_url'].values[0]
                    st.image(rec_photo_url, caption=rec['name'], width=100)
                    st.markdown(f"**Name:** {rec['name']}")
                    st.markdown(f"**Similarity Score:** {rec['similarity_score']}")
                    st.markdown(f"**Key Similarities:** {rec['key_similarities']}")
                    st.markdown(f"**Most Similar Fields:** {rec['most_similar_fields']}")
            
            # Display the deputy and recommendations data
            st.write("Deputy and Recommendations Data")
            st.write(df[df['deputy_id'] == deputy_id])
            st.write(df[df['deputy_id'].isin([rec['deputy_id'] for rec in recommendations['similar_deputies']])])
        
        except ValueError as e:
            st.error(f"Error: {e}")
        except Exception as e:
            st.error(f"Internal Error: {e}")

elif page == "Chat with Dataset":
    from langchain.chains import ConversationalRetrievalChain
    from langchain.chat_models import ChatOpenAI
    from langchain.embeddings import OpenAIEmbeddings
    from langchain.vectorstores import FAISS
    from langchain.memory import ConversationBufferMemory
    from langchain.text_splitter import CharacterTextSplitter
    from langchain.document_loaders import DataFrameLoader
    import os

    st.title("Chat with Dataset")
    st.write("This page allows you to chat with the dataset using a language model.")
    
    ## Add OpenAI API key input
    openai_api_key = st.sidebar.text_input("OpenAI API Key", type="password")
    
    # Initialize session state for chat history
    if "chat_history" not in st.session_state:
        st.session_state.chat_history = []
    
    # Create document database from DataFrame
    try:
        # Prepare documents
        loader = DataFrameLoader(df, page_content_column="name")
        documents = loader.load()
        
        # Split documents
        text_splitter = CharacterTextSplitter(chunk_size=1000, chunk_overlap=0)
        split_docs = text_splitter.split_documents(documents)
        
        # Create embeddings and vector store
        embeddings = OpenAIEmbeddings(openai_api_key=openai_api_key)
        vectorstore = FAISS.from_documents(split_docs, embeddings)
        
        # Create memory and chain
        memory = ConversationBufferMemory(memory_key="chat_history", return_messages=True)
        llm = ChatOpenAI(temperature=0, openai_api_key=openai_api_key)
        qa_chain = ConversationalRetrievalChain.from_llm(
            llm,
            vectorstore.as_retriever(),
            memory=memory,
            chain_type="stuff"
        )
    except Exception as e:
        st.error(f"Error initializing AI system: {e}")
    
    # Display chat history
    for message in st.session_state.chat_history:
        with st.chat_message(message["role"]):
            st.markdown(message["content"])
            if "plot" in message:
                st.plotly_chart(message["plot"], use_container_width=True)
    
    # Chat input
    if prompt := st.chat_input("Ask a question about the deputies dataset"):
        if not openai_api_key:
            st.error("Please enter your OpenAI API key in the sidebar")
            st.stop()
            
        try:
            # Add user message to history
            st.session_state.chat_history.append({"role": "user", "content": prompt})
            
            # Show user message
            with st.chat_message("user"):
                st.markdown(prompt)
            
            # Generate response
            response = qa_chain({"question": prompt})
            answer = response["answer"]
            
            # Check if answer contains plot instructions
            plot = None
            if "PLOT:" in answer:
                answer, plot_instruction = answer.split("PLOT:", 1)
                try:
                    # Parse plot instruction
                    plot_instruction = plot_instruction.strip()
                    if "HISTOGRAM OF" in plot_instruction:
                        column = plot_instruction.split("HISTOGRAM OF")[1].strip()
                        if column in df.columns:
                            fig = px.histogram(df, x=column, title=f"Distribution of {column}")
                            plot = fig
                    elif "SCATTER PLOT OF" in plot_instruction:
                        cols = plot_instruction.split("SCATTER PLOT OF")[1].strip().split(" vs ")
                        if len(cols) == 2 and all(c in df.columns for c in cols):
                            fig = px.scatter(df, x=cols[0].strip(), y=cols[1].strip(), 
                                           title=f"{cols[0]} vs {cols[1]}")
                            plot = fig
                except Exception as plot_error:
                    answer += f"\n\nError generating plot: {plot_error}"
            
            # Add AI response to history
            st.session_state.chat_history.append({
                "role": "assistant",
                "content": answer,
                "plot": plot
            })
            
            # Show AI response
            with st.chat_message("assistant"):
                st.markdown(answer)
                if plot:
                    st.plotly_chart(plot, use_container_width=True)
                    
        except Exception as e:
            st.error(f"Error processing your question: {e}")